# src/pyselect/networks.py
"""Networks based on layers specification."""
from typing import Callable

import torch
import torch.nn as nn
from torch import Tensor, Generator

from pyselect.layers import HadamardLayer
from pyselect.layers import RandomFourierFeaturesLayer


class RandomFourierFeaturesNet(nn.Module):
    """Linear one-layered neural network coupled with Random Fourier Features layer.

    Args:
        in_features (int): Number of features in the input tensor.
        out_features (int): Number of features generated by the Random Fourier Features layer. It is called **R** in the original Brecht (2007) article.
        sampler: Callable that samples from the chosen distribution. Determines the kernel the RFF method is aproximating.
        generator (Generator): torch generator object that manages the state of algorithm
        that produes pseudo random numbers. Used for the Random Fourier Features layer.
    """

    # TODO: final layer can be set to a different architecture.
    def __init__(
        self,
        in_features: int,
        out_features: int,
        sampler: Callable[[int, int, Generator], Tensor] = torch.randn,
        generator: Generator = torch.default_generator,
    ):
        """Constructor of the Random Fourier Features Network."""
        super(RandomFourierFeaturesNet, self).__init__()
        self.rff_net = nn.Sequential(
            HadamardLayer(in_features),
            RandomFourierFeaturesLayer(in_features, out_features, sampler, generator),
            nn.Linear(out_features, 1, bias=True),
        )

    def forward(self, x):
        """Perform a forward pass on the complete network."""
        output = self.rff_net(x)
        return output

    def get_bandwidths(self):
        """Get bandwidths from Hadamard Layer."""
        bandwidths = self.rff_net[0].bandwidths.detach()
        return bandwidths
